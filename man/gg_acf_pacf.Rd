% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/geom-acf.r
\name{geom_acf}
\alias{geom_acf}
\alias{geom_pacf}
\alias{stat_ACF}
\alias{stat_PACF}
\alias{stat_CONF}
\title{ACF And PACF For \code{ggplot2}}
\usage{
geom_acf(
  mapping = NULL,
  data = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_pacf(
  mapping = NULL,
  data = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

stat_ACF(
  mapping = NULL,
  data = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  lag.max = 20,
  exp = 1,
  ...
)

stat_PACF(
  mapping = NULL,
  data = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  lag.max = 20,
  exp = 1,
  ...
)

stat_CONF(
  mapping = NULL,
  data = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
}
\arguments{
\item{mapping}{Set of aesthetic mappings created by \code{\link[ggplot2:aes]{aes()}} or
\code{\link[ggplot2:aes_]{aes_()}}. If specified and \code{inherit.aes = TRUE} (the default),
it is combined with the default mapping at the top level of the plot. You must supply mapping
if there is no plot mapping.}

\item{data}{The data to be displayed in this layer. There are three options:

If \code{NULL}, the default, the data is inherited from the plot data as specified in the
call to \code{\link[ggplot2:ggplot]{ggplot()}}.

A \code{data.frame}, or other object, will override the plot data. All objects will be
fortified to produce a data frame. See \code{\link[ggplot2:fortify]{fortify()}} for which
variables will be created.

A function will be called with a single argument, the plot data. The return value must be a
\code{data.frame}, and will be used as the layer data. A function can be created from a
formula (e.g. ~ head(.x, 10)).}

\item{na.rm}{If \code{FALSE}, the dagult, missing values are removed with a warning. If
\code{TRUE}, missing values are silentry removed}

\item{show.legend}{logical. Shoud this layer be include in the legends? \code{NA}, de default,
includes if any aesthetics are mapped. \code{FALSE} never inlcudes and \code{TRUE} always
includes. It can also be a named logical vector to finely select the aesthetics to display}

\item{inherit.aes}{If \code{FALSE}, overrides the default aesthetics, rather than combining with
them. This is most useful for helper functions that define both data and aesthetics and
shouldn't inherit behaviour from the default plot specification, e.g.
\code{\link[ggplot2:borders]{borders()}}.}

\item{...}{Other arguments passed on to \code{\link[ggplot2:layer]{layer()}}. These are often
aesthetics, used to set an aesthetic to a fixed value, like \code{colour = "red"} or
\code{size = 3}. They may also be parameters to the paired geom/stat.}

\item{lag.max}{number of lags to plot}

\item{exp}{power to which the series will be exponentiated before computing its ACF of PACF. This
is meant as a facilitor when checking residuals for heterokedasticity}
}
\description{
\code{geoms} and \code{stats} for plotting ACF and PACF directly from data
}
\details{
\code{geom_acf} and \code{geom_pacf} take as \code{y} aesthetic the name of the column containing
the sereis whose ACF or PACF is to be plotted. This means that scaling functions such as
\code{\link[ggplot2:scale_y_continuous]{scale_y_continuous}} apply
\strong{DIRECTLY TO THE SERIES} and not to the autocorrelation values computed. To trim the plot,
use \code{\link[ggplot2:coord_cartesian]{coord_cartesian()}}
}
\section{Aesthetics}{


\code{geom_acf()} and \code{geom_pacf()} are essentially wrappers for \code{geom_line()}, so that
all aesthetics understood by it work with these new functions. The only required aesthetic is
\strong{y}
}

\examples{

# its still necessary to attach ggplot2 first
library(ggplot2)

dplot <- data.frame(series = arima.sim(1000, model = list(ar = .7)))

ggplot(dplot, aes(y = series)) + geom_acf()
ggplot(dplot, aes(y = series)) + geom_pacf()

ggplot(dplot, aes(y = series)) + geom_acf(lag.max = 150)

# exp option is more useful when checking for heterokedasticity
ggplot(dplot, aes(y = series)) + geom_acf(exp = 2)

# There is a problem when using scale_y_continuous that distorts the autocorrelation values. 
# Should the user want to limit the y axis, coord_cartesian should be used
ggplot(dplot, aes(y = series)) + geom_acf() + coord_cartesian(ylim = c(0, .3))

}
